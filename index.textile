---
layout: quirkey_code
title: Restful Query
github_name: restful_query
current_version: 0.2.0
plugin: true
nav:
  - name: What
    link: "#what"
  - name: Why
    link: "#why"
  - name: Usage
    link: "#usage"
  - name: Dependencies
    link: "#dependencies"
---

h2(project_name). {{ page.title }}

h3(#what). What

Restful Query is a module that when included in ActiveRecord  or Sequel (as of 0.3.0) supplies an easy and safe way to query a database through a RESTful resource.

h3(#why). Why

The general RESTful resource generated by Rails and widely used across the community supplies only basic CRUD (Create Read Update Delete) functionality. The index action usually provides a list (probably paginated) of all the records for a given resource or within a given scope. Restful Query provides an easy way to create a RESTful API for querying records for a given resource. 

For example, given a resource of Book, say you want to get a list of all Books whose created or added to the system in the last two weeks. The common solution would be to create another action on the resource for querying the books by date. With Restful Query its as easy as:

{% highlight bash %}
/books?query[created_at][gt]=2 weeks ago
{% endhighlight %}

Restful Query allows you to query the books by any and as many parameters you want and want to allow. 

h3(#usage). Usage

RestfulQuery provides extensions for both ActiveRecord and Sequel. The only difference is how to enable the extension.

h4. With ActiveRecord/Rails

Including Restful Query in your Rails project is easy. Install it as a plugin or a gem in your app. 

In the ActiveRecord model you want to query, invoke the can_query macro:

{% highlight ruby %}
class Book < ActiveRecord::Base

  can_query

end
{% endhighlight %}

This will add a few methods to your model, notably the named_scope @restful_query@

h4. With Sequel

RestfulQuery includes an extension for Sequel. Once the gem is installed:

{% highlight ruby %}
require 'sequel/extensions/restful_query'
{% endhighlight %}

This extends the Sequel::Dataset class, allowing you to filter/order a dataset using the @restful_query@ method.

h4. General Usage

@restful_query@ takes a hash with a special format and converts it into a conditions array. The format is intended to be easy to interpret and read within the URL as well as be easy to pass as Rails-like form params.

The ruby hash should look something like:

{% highlight ruby %}
params[:query] = {'column' => {'operator' => 'value', ...}, ...}
{% endhighlight %}

Which looks like this before being coverted by ActionController's params parser:

{% highlight bash %}
?query[column][operator]=value&...
{% endhighlight %}

A query can be made up of as many @operators@ on as many @columns@ as you like.

A @column@ is a literal column in the database. You can query across tables by passing the @:include@ option to the @can_query@ macro. You can also exclude columns you dont want queried (password, private info) by passing @:exclude_columns@ to @can_query@ with an array of column names.

An @operator@ is one of the following:

|_.Restful Query|_.SQL|_.English|
|lt|<|Less than|
|gt|>|Greater than|
|gteq|>=|Greater than or equal to|
|lteq|<=|Less than or equal to|
|eq|=|Equal to|
|neq|!=|Not equal to|
|like|LIKE|Similar to|
|is|IS|is|
|is not|IS NOT|is not|
|in|IN|Is in (set)|
|notin|NOT IN|Is not in (set)|

Multiple @operators@ can be passed to for a single @column@ like:

{% highlight ruby %}
{'created_at' => {'gt' => '1 day ago', 'lt' => '1 hour ago'}}
{% endhighlight %}

There's also a shorcut to 'eq' by eliminating the @operator@:

{% highlight ruby %}
{'name' => 'Programming Ruby'}
{% endhighlight %}

is equivilent to:

{% highlight ruby %}
{'name' => {'eq' => 'Programming Ruby'}}
{% endhighlight %}

A @value@ is a string passed evaluated in the ActiveRecord conditions array. In the case of Date and Time like objects, Restful Query can make use of the @chronic@ gem to parse string representations of time like those written about above. This solves for a lot of the inconsitancis between different languages/classes/apps representations of time as a string. If you pass @:chronic => true@ to @can_query@ the parser will automaticaly interpret the @created_at@ and @updated_at@ columns through chronic. If there are differnt columns you wish to interpret through chronic pass them in an array to @:chronic@ in @can_query@. e.g:

{% highlight ruby %}
class Book < ActiveRecord::Base

  can_query :chronic => ['last_viewed_at', :updated_at]

end
{% endhighlight %}

Restful Query also provides the ability to sort/order results by passing a @_sort@ key to the @restful_query@ named_scope. @_sort@ takes an array of strings with a simple but specific format of:

{% highlight ruby %}
column-direction
{% endhighlight %}

Where direction is one of:

* asc
* desc
* up
* down

For example:

{% highlight ruby %}
{'created_at' => {'gt' => '1 day ago'}, '_sort' => 'created_at-desc'}
{% endhighlight %}

or with multiple:

{% highlight ruby %}
{'created_at' => {'gt' => '1 day ago'}, '_sort' => ['created_at-desc', 'name-asc']}
{% endhighlight %}

You can aslo pass a @:default_sort@ option to @can_query@ using the format above.

Implementing Restful Query in a resource index super simple. First, include the macro in the model, then in the controller:

{% highlight ruby %}
class BooksController < ApplicationController

  def index
    @books = Book.restful_query(params[:query]).paginate(:page => (params[:page] || 1), :per_page => 20) 
    respond_to do |format|
      format.html 
      format.xml { render :xml => @books}
    end
  end
  
  ...
end
{% endhighlight %}

Since @restful_query@ is just a named_scope it can be chained with other find/scope operations as with will_paginate's @paginate@ above.

Restful Query is also used to great effect in another gem o' mine: "qadmin":http://code.quirkey.com/qadmin

h3(#dependencies). Dependencies

* rubygems >= 1.3.1
* chronic >= 0.2.3
* activesupport >= 2.2.0
